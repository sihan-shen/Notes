
## 为什么需要并行程序？
- 内存障碍（memory-wall）
- 能耗、散热障碍（power-wall）
- 稳定性障碍（reliability-wall）
- 芯片开发成本上升：28nm芯片开发需要5130万美元，16nm需要1亿美元，7nm需要2.97亿美元

## 并行计算资源
- 单台多核
- 单台众核
  - 例如：Huawei Atlas 900 AI集群
- 多台集群
- 多核CPU + GPU + FPGA + TPU + 集群

## 并发与并行
- 并发：同一时间段内可以交替处理多个操作
- 并行：同一时刻内同时处理多个操作

## 进程与线程
- **进程（process）**
  - 在内存中运行的应用程序
  - 有独立的内存空间
  - 一个进程可以有多个线程
- **线程（thread）**
  - 进程中的执行任务
  - 共享进程的堆和方法区资源
  - 每个线程有自己的程序计数器和本地方法栈

## C++并行编程

### 线程基础
- 线程随着`std::thread`类型实例的创建而创建
- 创建线程需指定线程函数

### 线程结束方式
- `join`: 主线程阻塞，直到子线程退出
- `detach`: 主线程丧失对子线程控制权
  - 主线程结束后子线程可能仍在运行
  - 需保证子线程不引用主线程资源

### 线程管理
- `get_id`: 返回当前线程id
- `sleep_for`: 让当前线程停止一段时间
- `sleep_until`: 以具体时间点为参数停止线程

### 数据竞争与临界区
- **数据竞争（data race）**: 多个进程/线程同时访问共享数据，至少一个修改数据
- **临界区（critical section）**: 访问共享数据的代码片段
- 避免竞争条件需对临界区进行数据保护

### 互斥体与锁
- 互斥元/锁：保护共享数据的基本机制
- 访问共享数据前锁定互斥元，访问后解锁
- `std::lock_guard`: 构造时锁定互斥元，析构时解锁

### 并行算法
- C++17开始，`<algorithm>`和`<numeric>`中算法添加`sequenced_policy`参数
- 需要gcc 9.0+和Intel Threading Building Blocks支持

## 扩展阅读
- **CUDA GPU编程**
  - [CUDA教程](https://cuda-tutorial.readthedocs.io/en/latest/tutorials/tutorial01/)
  - [CUDA编程指南](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html)
- **OpenMP**
  - [OpenMP教程](https://computing.llnl.gov/tutorials/openMP/)
- **MPI**
  - [MPI教程](https://mpitutorial.com/tutorials/)
  - [MPI教程](https://computing.llnl.gov/tutorials/mpi/)