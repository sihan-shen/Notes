
## 什么时候需要多继承？
- 示例：定义类C包含类A和B的所有成员，并新增成员r和fc

## 单继承实现方式
```cpp
class C: public A {
    int n,r; // 复制B类的n
public:
    void fb(); // 复制B类的fb
    void fc();
};
```
或
```cpp
class C: public B {
    int m,r; // 复制A类的m
public:
    void fa(); // 复制A类的fa
    void fc();
};
```
### 不足之处
1. 易造成不一致
2. 不能完全实现子类型

## 成员对象实现方式
```cpp
class C {
    A a;
    B b;
    int r;
public:
    void fa() { a.fa(); }
    void fb() { b.fb(); }
    void fc();
};
```
### 不足之处
- 不能实现子类型

## 多继承实现方式
```cpp
class C: public A, public B {
    int r;
public:
    void fc();
};
```
- 优点：自然描述对象类间的多继承关系

## 多继承的类定义
```cpp
class <派生类名>: [<继承方式>] <基类名1>,
                 [<继承方式>] <基类名2>, ... {
    <成员说明表>
};
```
### 特点
1. 继承方式及访问控制同单继承
2. 派生类拥有所有基类成员
3. 基类声明次序决定：
   - 数据成员存储安排
   - 构造函数/析构函数调用次序

## 多继承示例
```cpp
C c;
c.fa(); // OK
c.fb(); // OK
c.fc(); // OK
```
### 内存布局
```
A::m
B::n
C::r
```
### 构造函数执行次序
A() → B() → C()

## 多继承的对象替代
- C类对象可替代A类或B类对象
- 地址自动调整示例：
```cpp
C c;
A *pa = &c;
B *pb = &c;
```

## 多继承带来的问题
1. 语言特征复杂化
2. 名冲突问题
3. 重复继承问题

### 名冲突问题示例
```cpp
class C: public A, public B {
    void func() {
        f(); // Error: 歧义
    }
};
```
#### 解决方法：基类名受限
```cpp
A::f(); // 调用A的f
B::f(); // 调用B的f
```

### 重复继承问题（虚基类）
```cpp
class A { int x; };
class B: public A { };
class C: public A { };
class D: public B, public C { };
```
- D类对象包含两个x：B::x和C::x

#### 解决方法：虚基类
```cpp
class B: virtual public A { };
class C: virtual public A { };
class D: public B, public C { };
```
- D类对象只有一个x

## 虚基类构造函数的调用
1. 由最新派生出的类的构造函数直接调用
2. 优先于非虚基类的构造函数执行

### 虚基类构造函数示例
```cpp
D(int i, int j, int k): B(i), C(j), A(3) { m = k; }
```
- 调用次序：A(3) → B(1) → C(2) → D(1,2,3)

## 虚基类的实现
### 非虚基类内存布局
```
x: (B::A)
y: (B)
x: (C::A)
z: (C)
m: (D)
```

### 虚基类实现方式
- x移到最后，在原位置存储偏移量指针
- 通过虚基类表(vbtable)访问