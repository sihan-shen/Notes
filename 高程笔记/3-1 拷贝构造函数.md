
## 定义
- 若一个构造函数的参数类型为本类的引用，则称它为拷贝构造函数
```cpp
class A {
    ......
public:
    A();  //默认构造函数
    A(const A& a);  //拷贝构造函数
};
```

## 调用场景
1. 创建对象时显式指出
```cpp
A a1;
A a2(a1);  //创建对象a2，用对象a1初始化对象a2
```

2. 把对象作为值参数传给函数时
```cpp
void f(A x) { ...... };
A a;
f(a);  //创建形参对象x，用对象a对x进行初始化
```

3. 把对象作为函数的返回值时
```cpp
A f() {
    A a;
    ......
    return a; //创建一个临时对象，用对象a对创建的临时对象进行初始化
}
```

## 隐式拷贝构造函数
- 如果没有为某个类提供拷贝构造函数，编译器会生成一个隐式拷贝构造函数
- 工作方式：
  - 对于非对象成员：采用通常的拷贝操作
  - 对于成员对象：调用成员对象类的拷贝构造函数（递归定义）

### 示例
```cpp
class A {
    int x,y;
public:
    A() { x = y = 0; }
    ......
};

class B {
    int z;
    A a;
public:
    B() { z = 0; }
    ...... //没有定义拷贝构造函数
};

B b1; //b1.z以及b1.a.x和b1.a.y均为0
B b2(b1); //b2.z初始化成b1.z；调用A的拷贝构造函数用b1.a对b2.a初始化
```

## 自定义拷贝构造函数
- 一般情况下隐式拷贝构造函数足够
- 某些情况下必须自定义，否则会产生严重错误

### 示例问题
```cpp
class String {
    int len;
    char *str;
public:
    String(char *s) {
        len = strlen(s);
        str = new char[len+1];
        strcpy(str,s);
    }
    ~String() { delete []str; len=0; str=NULL; }
};

String s1("abcd");
String s2(s1);
```
问题：
1. s1和s2的str指向同一内存区域
2. 修改一个对象会影响另一个
3. 同一内存会被释放两次

## 深拷贝解决方案
```cpp
String::String(const String& s) {
    len = s.len;
    str = new char[len+1];
    strcpy(str,s.str);
}
```

## 成员对象初始化注意事项
- 自定义拷贝构造函数默认调用成员对象类的默认构造函数
- 如需调用成员对象类的拷贝构造函数，需在成员初始化表中显式指出

### 示例
```cpp
class A {
    int x,y;
public:
    A() { x = y = 0; }
    void inc() { x++; y++; }
};

class B {
    int z;
    A a;
public:
    B() { z = 0; }
    B(const B& b) : a(b.a) { z = b.z; }  //显式调用A的拷贝构造函数
    void inc() { z++; a.inc(); }
};
```

## 赋值初始化与拷贝构造的区别
```cpp
class A { ...... };

class B {
    int z;
    A a;
public:
    B() { ...... }
    B(const B& b) {
        z = b.z;
        a = b.a;  //先调用A的默认构造函数，再调用赋值操作
    }
    ......
};
```