
## 继承不是类代码复用的唯一方式
- 继承体现类之间的一般与特殊关系（is-a-kind-of）
- 不宜用继承的情况：
  - 两个类之间没有一般与特殊关系
  - 纯粹为了代码复用而使用继承会造成概念混乱
- 示例：飞机类复用发动机类的功能不宜用继承

## 类之间的整体与部分关系
- 类之间存在整体与部分关系（is-a-part-of）
- 一个类的对象包含另一个类的对象
- 示例：飞机类与发动机类
- 两种关系类型：
  - 聚合（aggregation）
  - 组合（composition）

## 聚合
- 被包含对象与包含对象独立创建和消亡
- 被包含对象可以独立存在
- 示例：公司与员工
- 实现方式：
  - 聚合类使用对象指针指向成员对象
  - 成员对象在外部创建后传入

### 聚合示例代码
```cpp
class A { ...... };
class B { // B与A是聚合关系
    A *pm; // 指向成员对象
public:
    B(A *p) { pm = p; } // 成员对象在外部创建后传入
    ~B() { pm = NULL; } // 成员对象不再属于聚合类
    ......
};
```

### 公司与员工示例
```cpp
class Employee { // 职员类
    string name;
    int salary;
public:
    Employee(const char *s, int n=0):name(s) { salary = n; }
    void set_salary(int n) { salary = n; }
    int get_salary() const { return salary; }
    ......
};

class Company { // 公司类
    String name;
    Employee *group[MAX_NUM_OF_EMPS]; // 职员数组
    int num_of_emps; // 职员人数
public:
    Company(const char *s):name(s) { num_of_emps = 0; }
    ~Company() { num_of_emps = 0; }
    bool add_employee(Employee *e);
    bool remove_employee(Employee *e);
    int get_num_of_emps() { return num_of_emps; }
    ......
};
```

## 组合
- 被包含对象随包含对象创建和消亡
- 被包含对象不能独立存在
- 示例：人与头、手、脚
- 实现方式：
  - 成员对象在组合类内部创建
  - 随组合类对象消亡

### 组合示例代码
```cpp
class A { ...... };
class C { // C与A是组合关系
    A a; // 直接成员对象
public:
    ......
};

// 或使用指针形式
class C { // C与A是组合关系
    A *pm; // 指向成员对象
public:
    C() { pm = new A; } // 成员对象在内部创建
    ~C() { delete pm; } // 成员对象随组合类消亡
    ......
};
```

## 线性表与队列示例
### 线性表类
```cpp
class LinearList {
    ......
public:
    bool insert(int x, int pos);
    bool remove(int &x, int pos);
    int element(int pos) const;
    int search(int x) const;
    int length() const;
};
```

### 队列实现1（组合）
```cpp
class Queue {
    LinearList list;
public:
    bool en_queue(int i) { return list.insert(i,list.length()); }
    bool de_queue(int &i) { return list.remove(i,1); }
};
```

### 队列实现2（继承）
```cpp
class Queue: private LinearList {
public:
    bool en_queue(int x) { return insert(x,length()); }
    bool de_queue(int &x) { return remove(x,1); }
};
// private继承已退化为组合
```

## 继承与聚合/组合的比较
- 继承提供两种接口：
  - public：对象用户
  - public+protected：派生类用户
- 聚合/组合只需一个接口：public

## 组合替代继承实现代码复用
```cpp
class A {
public:
    void f();
    void g();
};

// 组合方式
class B {
    A a;
public:
    void f() { a.f(); }
    void g() { a.g(); }
    void h();
    ......
};

// 继承方式
class B: public A {
public:
    void h();
    ......
};
```

## 继承与子类型
- public继承的派生类可视为基类的子类型
- 派生类对象可替代基类对象使用
- 聚合/组合关系的类不具有子类型关系