## 数据抽象与封装概述
- **目的**：抽象与封装是重要的程序设计手段，用于驾驭程序复杂度，便于大型程序的设计、理解和维护。
- **抽象**：强调程序实体的外部可观察行为，不关心内部实现，用于控制复杂度。
- **封装**：隐藏程序实体内部的实现细节，仅通过接口对外提供服务，用于信息保护。
- **关系**：抽象是一种思维方式，封装是基于抽象的操作方法。
- **机制**：主要的抽象与封装机制包括==**过程**==抽象与封装、==**数据**==抽象与封装。

---
## 过程抽象与封装
- **过程抽象**：
  - 使用一个名字代表一段完成特定功能的代码。
  - 使用者只需知道代码的名字和功能，无需了解内部实现。
- **过程封装**：
  - 隐藏代码的具体实现，使用者通过名字调用代码。
  - 数据通过参数或全局变量传递，结果通过返回值或全局变量返回。
- **实现**：实现过程抽象与封装的程序实体称为子程序，在C/C++中用函数表示。
- **特点**：
  - 基于功能分解与复合的**过程式程序设计**基础。
  - ==*数据公开*==，缺乏保护。

---
## 数据抽象与封装
- **数据抽象**：
  - 描述对数据的操作及操作之间的关系，使用者无需了解数据的具体表示形式。
- **数据封装**：
  - 将数据及其操作作为一个整体封装，隐藏数据的具体表示，使用者只能通过封装体的接口操作数据。
- **优势**：相比过程抽象与封装，数据抽象与封装能实现更好的数据保护。
- **应用**：数据抽象与封装是==**面向对象程序设计**==的基础，**对象**体现了数据抽象与封装。

---
## 栈的实现案例
### 非抽象和封装途径
- **数据定义**：
  ```cpp
  const int STACK_SIZE = 100;
  struct Stack {
      int top;
      int buffer[STACK_SIZE];
  };
  ```
- **操作方式**：
  - 直接操作栈数据，如初始化、进栈和退栈。
  - 示例代码：
    ```cpp
    Stack st;
    st.top = -1; // 初始化
    if (st.top == STACK_SIZE - 1) {
        cout << "Stack is overflow.\n";
        exit(-1);
    }
    st.top++;
    st.buffer[st.top] = 12; // 进栈
    int x;
    if (st.top == -1) {
        cout << "Stack is empty.\n";
        exit(-1);
    }
    x = st.buffer[st.top];
    st.top--; // 退栈
    ```
- **问题**：
  - 操作必须知道数据的具体表示形式。
  - 数据表示形式变化会影响操作。
  - 容易误操作，如忘记初始化或错误修改`top`。

---
### 过程抽象与封装操作栈数据
- **函数定义**：
  ```cpp
  void push(Stack &s, int i) {
      if (s.top == STACK_SIZE - 1) {
          cout << "Stack is overflow.\n";
          exit(-1);
      } else {
          s.top++;
          s.buffer[s.top] = i;
      }
  }

  void pop(Stack &s, int &i) {
      if (s.top == -1) {
          cout << "Stack is empty.\n";
          exit(-1);
      } else {
          i = s.buffer[s.top];
          s.top--;
      }
  }

  void init(Stack &s) {
      s.top = -1;
  }
  ```
- **操作方式**：
  ```cpp
  Stack st;
  int x;
  init(st); // 初始化
  push(st, 12); // 进栈
  pop(st, x); // 退栈
  ```
- **问题**：
  - 数据类型定义与操作定义分开，未进行统一封装。
  - 数据表示公开，无法防止直接操作栈数据，仍存在安全问题。

---
### 数据抽象和封装途径
- **类定义**：
  ```cpp
  const int STACK_SIZE = 100;
  class Stack {
  public:
      Stack(); // 构造函数
      void push(int i);
      void pop(int &i);
  private:
      int top;
      int buffer[STACK_SIZE];
  };
  ```
- **成员函数实现**：
  ```cpp
  Stack::Stack() {
      top = -1;
  }

  void Stack::push(int i) {
      if (top == STACK_SIZE - 1) {
          cout << "Stack is overflow.\n";
          exit(-1);
      } else {
          top++;
          buffer[top] = i;
      }
  }

  void Stack::pop(int &i) {
      if (top == -1) {
          cout << "Stack is empty.\n";
          exit(-1);
      } else {
          i = buffer[top];
          top--;
      }
  }
  ```
- **操作方式**：
  ```cpp
  Stack st; // 自动调用构造函数初始化
  int x;
  st.push(12); // 进栈
  st.pop(x); // 退栈
  ```
- **优势**：
  - 数据和操作封装在一起，隐藏数据的具体表示。
  - 使用者无法直接访问内部数据，只能通过接口操作，提高了安全性。

---
### 栈的另一种实现（链表表示）
- **类定义**：
  ```cpp
  class Stack {
  public:
      Stack();
      void push(int i);
      void pop(int &i);
  private:
      struct Node {
          int content;
          Node *next;
      } *top;
  };
  ```
- **成员函数实现**：
  ```cpp
  Stack::Stack() {
      top = NULL;
  }

  void Stack::push(int i) {
      Node *p = new Node;
      if (p == NULL) {
          cout << "Stack is overflow.\n";
          exit(-1);
      } else {
          p->content = i;
          p->next = top;
          top = p;
      }
  }

  void Stack::pop(int &i) {
      if (top == NULL) {
          cout << "Stack is empty.\n";
          exit(-1);
      } else {
          Node *p = top;
          top = top->next;
          i = p->content;
          delete p;
      }
  }
  ```
- **操作方式**：
  ```cpp
  Stack st;
  int x;
  st.push(12);
  st.pop(x);
  ```
- **优势**：
  - 改变数据表示（从数组到链表）对使用者无影响，体现了数据抽象和封装的强大功能。

---
## 总结
- **抽象与封装**：抽象关注外部行为，封装隐藏内部实现，二者结合可有效降低程序复杂度，提高可维护性。
- **过程抽象与封装**：基于功能分解，适用于过程式程序设计，但数据保护较弱。
- **数据抽象与封装**：将数据和操作封装为一个整体，隐藏数据实现，提供接口操作，是面向对象程序设计的核心。
- **案例分析**：通过栈的实现案例，展示了从非抽象和封装到数据抽象和封装的演进过程，强调了封装在数据保护和安全性方面的优势。