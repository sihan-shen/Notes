
## 操作符重载概述
- C++允许对已有操作符进行重载，使其能对自定义类型（类）的对象进行操作
- 实现多态性的一种语言机制

### 需要性示例
```cpp
class Complex {  //复数类定义
    double real, imag;
public:
    Complex(double r=0.0, double i=0.0) { real=r; imag=i; }
    void display() const { cout << real << '+' << imag << 'i'; }
};
```
问题：如何实现两个复数相加？

#### 方案1：成员函数add
```cpp
class Complex {
public:
    Complex add(const Complex& x) const {
        Complex temp;
        temp.real = real+x.real;
        temp.imag = imag+x.imag;
        return temp;
    }
};
// 使用：c = a.add(b);
```

#### 方案2：全局函数add
```cpp
class Complex {
    friend Complex add(const Complex& x1, const Complex& x2);
};
Complex add(const Complex& x1, const Complex& x2) {
    Complex temp;
    temp.real = x1.real+x2.real;
    temp.imag = x1.imag+x2.imag;
    return temp;
}
// 使用：c = add(a,b);
```

## 操作符重载实现途径
1. 作为类的非静态成员函数（操作符new和delete除外）
2. 作为全局（友元）函数
   - 至少一个参数是类、结构、枚举或它们的引用类型
   - 重载函数名格式：`operator #`（#代表任意可重载操作符）

### 成员函数重载示例
```cpp
class Complex {
public:
    Complex operator + (const Complex& x) const {
        Complex temp;
        temp.real = real+x.real;
        temp.imag = imag+x.imag;
        return temp;
    }
};
// 使用：c = a + b;
```

### 全局函数重载示例
```cpp
class Complex {
    friend Complex operator + (const Complex& c1, const Complex& c2);
};
Complex operator + (const Complex& c1, const Complex& c2) {
    Complex temp;
    temp.real = c1.real + c2.real;
    temp.imag = c1.imag + c2.imag;
    return temp;
}
// 使用：c = a + b;
```

## 操作符重载基本原则
1. 只能重载C++已有操作符，不可臆造新操作符
2. 不能重载的操作符：".", ".*", "?:", "::", "sizeof"
3. 遵循已有操作符的语法：
   - 不能改变操作数个数
   - 不改变原操作符的优先级和结合性
4. 尽量遵循已有操作符原来的语义

## 双目操作符重载

### 作为成员函数重载
```cpp
class <类名> {
    <返回值类型> operator # (<类型>);
};
<返回值类型> <类名>::operator # (<类型> <参数>) { ... }

// 使用：
<类名> a; <类型> b;
a # b 或 a.operator#(b)
```

#### 示例：复数"等于"和"不等于"
```cpp
class Complex {
public:
    bool operator ==(const Complex& x) const {
        return (real == x.real) && (imag == x.imag);
    }
    bool operator !=(const Complex& x) const {
        return !(*this == x);
    }
};
// 使用：if (c1 == c2) 或 if (c1 != c2)
```

### 作为全局函数重载
```cpp
<返回值类型> operator #(<类型1> <参数1>, <类型2> <参数2>) { ... }

// 使用：
<类型1> a; <类型2> b;
a # b 或 operator#(a,b)
```

#### 示例：实数与复数混合运算
```cpp
class Complex {
    friend Complex operator + (const Complex& c1, const Complex& c2);
    friend Complex operator + (const Complex& c, double d);
    friend Complex operator + (double d, const Complex& c);
};

Complex operator + (const Complex& c, double d) {
    return Complex(c.real+d, c.imag);
}
Complex operator + (double d, const Complex& c) {
    return Complex(d+c.real, c.imag);
}
// 使用：
c1 = a + b; c2 = b + 21.5; c3 = 10.2 + a;
```

## 单目操作符重载

### 作为成员函数重载
```cpp
class <类名> {
    <返回值类型> operator # ();
};
<返回值类型> <类名>::operator # () { ... }

// 使用：
<类名> a;
#a 或 a.operator#()
```

#### 示例：复数取负
```cpp
class Complex {
public:
    Complex operator -() const {
        Complex temp;
        temp.real = -real;
        temp.imag = -imag;
        return temp;
    }
};
// 使用：b = -a;
```

### 作为全局函数重载
```cpp
<返回值类型> operator #(<类型> <参数>) { ... }

// 使用：
<类型> a;
#a 或 operator#(a)
```

#### 示例：判断复数为零
```cpp
class Complex {
    friend bool operator !(const Complex &c);
};
bool operator !(const Complex &c) {
    return (c.real == 0.0) && (c.imag == 0.0);
}
// 使用：if (!a) ...
```

## 操作符++和--的重载
- 需要区分前置与后置用法
- 后置用法重载函数带一个int型参数（函数体中可不使用）

### 示例
```cpp
class Counter {
    int value;
public:
    Counter& operator ++() {  // 前置++
        value++;
        return *this;
    }
    const Counter operator ++(int) {  // 后置++
        Counter temp=*this;  // 保存原对象
        ++(*this);  // 调用前置++
        return temp;  // 返回原对象
    }
};
// 使用：
++a;  // 前置
a++;  // 后置
b = ++a;  // 加一后的a赋值给b
c = a++;  // 加一前的a赋值给c
```