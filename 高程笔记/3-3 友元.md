
## 友元的概念
- 根据数据封装的要求，类中定义的数据成员不能在外界直接访问，必须通过public成员函数访问
- 在某些情况下，这种访问方式效率不高
- 友元是数据保护和数据访问效率之间的折衷方案
- 友元允许特定程序实体直接访问类的非public成员

## 友元的定义
- 需要在类中用`friend`显式指出
- 友元可以是：
  - 全局函数
  - 其他类
  - 其他类的成员函数

```cpp
class A {
    friend void func();      // 全局函数func可访问x
    friend class B;          // 类B的所有成员函数可访问x
    friend void C::f();      // 类C的成员函数f可访问x
private:
    int x;
};
```

## 友元的特性
1. 友元不是一个类的成员
2. 友元关系具有不对称性
   - 如果B是A的友元，A不自动成为B的友元
3. 友元不具有传递性
   - 如果C是B的友元，B是A的友元，C不自动成为A的友元

## 矩阵与向量相乘示例

### 矩阵类定义
```cpp
class Matrix {
    int *p_data;  // 矩阵数据
    int row, col; // 行数和列数
public:
    Matrix(int r, int c) {
        if (r <= 0 || c <= 0) {
            cerr << "矩阵尺寸不合法！\n";
            exit(-1);
        }
        row = r; col = c;
        p_data = new int[row*col];
        for (int i=0; i<row*col; i++) p_data[i] = 0;
    }
    ~Matrix() { delete []p_data; }
    
    int &element(int i, int j) {
        if (i < 0 || i >= row || j < 0 || j >= col) {
            cerr << "矩阵下标越界\n";
            exit(-1);
        }
        return *(p_data+i*col+j);
    }
    
    int element(int i, int j) const {
        if (i < 0 || i >= row || j < 0 || j >= col) {
            cerr << "矩阵下标越界\n";
            exit(-1);
        }
        return *(p_data+i*col+j);
    }
    
    int dimension_row() const { return row; }
    int dimension_column() const { return col; }
    
    void display() const {
        int *p=p_data; 
        for (int i=0; i<row; i++) {
            for (int j=0; j<col; j++) {
                cout << *p << ' ';
                p++;
            }
            cout << endl;
        }
    }
};
```

### 向量类定义
```cpp
class Vector {
    int *p_data;
    int num;
public:
    Vector(int n) {
        if (n <= 0) {
            cerr << "向量尺寸不合法！\n"; 
            exit(-1);
        }
        num = n;
        p_data = new int[num];
        for (int i=0; i<num; i++) p_data[i] = 0;
    }
    ~Vector() { delete []p_data; }
    
    int &element(int i) {
        if (i < 0 || i >= num) {
            cerr << "向量下标越界！\n";
            exit(-1);
        }
        return p_data[i];
    }
    
    int element(int i) const {
        if (i < 0 || i >= num) {
            cerr << "向量下标越界！\n";
            exit(-1);
        }
        return p_data[i];
    }
    
    int dimension() const { return num; }
    
    void display() const {
        int *p=p_data;
        for (int i=0; i<num; i++,p++)
            cout << *p << ' ';
        cout << endl;
    }
};
```

### 非友元实现
```cpp
void multiply(const Matrix &m, const Vector &v, Vector &r) {
    if (m.dimension_column() != v.dimension() || 
        m.dimension_row() != r.dimension()) {
        cerr << "矩阵和向量的尺寸不匹配！\n";
        exit(-1);
    }
    int row=m.dimension_row(), col=m.dimension_column();
    for (int i=0; i<row; i++) {
        r.element(i) = 0;
        for (int j=0; j<col; j++)
            r.element(i) += m.element(i,j)*v.element(j);
    }
}
```

### 友元实现
1. 声明友元关系
```cpp
class Vector; // 前向声明

class Matrix {
    friend void multiply(const Matrix &m, const Vector &v, Vector &r);
    // ...
};

class Vector {
    friend void multiply(const Matrix &m, const Vector &v, Vector &r);
    // ...
};
```

2. 友元函数实现
```cpp
void multiply(const Matrix &m, const Vector &v, Vector &r) {
    if (m.col != v.num || m.row != r.num) {
        cerr << "矩阵和向量的尺寸不匹配！\n";
        exit(-1);
    }
    int *p_m=m.p_data, *p_r=r.p_data, *p_v;
    for (int i=0; i<m.row; i++) {
        *p_r = 0;
        p_v = v.p_data;
        for (int j=0; j<m.col; j++) {
            *p_r += (*p_m)*(*p_v);
            p_m++;
            p_v++;
        }
        p_r++;
    }
}
```