
## 纯虚函数
- 纯虚函数是没给出实现的虚函数，函数体用"=0"表示
- 示例：
```cpp
class A {
    ......
    public:
        virtual int f()=0; //纯虚函数
    ......
};
```
- 纯虚函数需要在派生类中给出实现

## 抽象类定义
- 包含纯虚函数的类称为抽象类
- 抽象类不能用于创建对象
- 示例：
```cpp
class A { //抽象类
    ......
    public:
        virtual int f()=0; //纯虚函数
    ......
};
......
A a;  //Error，A是抽象类
```
- 作用：为派生类提供一个基本框架和一个公共的对外接口

## 图形类示例
### 抽象基类Figure
```cpp
class Figure { //抽象基类
    public:
        virtual void draw() const=0;
        virtual void input_data()=0;
};
```

### 派生类实现
#### Rectangle类
```cpp
class Rectangle: public Figure {
    double left,top,right,bottom;
    public:
        void draw() const { ...... } //画矩形
        void input_data() {
            cout << "请输入矩形的左上角和右下角坐标 (x1,y1,x2,y2) ：";
            cin >> left >> top >> right >> bottom;
        }
        double area() const { return (bottom-top)*(right-left); }
};
```

#### Circle类
```cpp
const double PI=3.1416;
class Circle: public Figure {
    double x,y,r;
    public:
        void draw() const { ...... } //画圆
        void input_data() {
            cout << "请输入圆的圆心坐标和半径 (x,y,r) ：";
            cin >> x >> y >> r;
        }
        double area() const { return r*r*PI; }
};
```

#### Line类
```cpp
class Line: public Figure {
    double x1,y1,x2,y2;
    public:
        void draw() const { ...... } //画线
        void input_data() {
            cout << "请输入线段的起点和终点坐标 (x1,y1,x2,y2) ：";
            cin >> x1 >> y1 >> x2 >> y2;
        }
};
```

### 使用示例
```cpp
const int MAX_NUM_OF_FIGURES=100;
Figure *figures[MAX_NUM_OF_FIGURES];
int count=0;
```

#### 图形数据输入
```cpp
for (count=0; count<MAX_NUM_OF_FIGURES; count++) {
    int shape;
    do {
        cout << "请输入图形的种类(0：线段，1：矩形，2：圆，-1：结束)：";
        cin >> shape;
    } while (shape < -1 || shape > 2);
    if (shape == -1) break;
    switch (shape) {
        case 0: //线
            figures[count] = new Line; break;
        case 1: //矩形
            figures[count] = new Rectangle; break;
        case 2: //圆
            figures[count] = new Circle; break;
    }
    figures[count]->input_data(); //动态绑定
}
```

#### 图形输出
```cpp
for (int i=0; i<count; i++)	
    figures[i]->draw(); //动态绑定
```
- 多态优势：高层代码复用，增加新图形种类时无需修改高层代码

## 联合类型实现对比
### 数据结构定义
```cpp
struct Line { double x1,y1,x2,y2; };
struct Rectangle { double left,top,right,bottom; };
struct Circle { double x,y,r; };
union Figure {
    Line line;
    Rectangle rect;
    Circle circle; 
};
struct TaggedFigure {
    int shape;
    Figure figure; 
};
const int MAX_NUM_OF_FIGURES=100;
TaggedFigure *figures[MAX_NUM_OF_FIGURES];
```

### 操作函数
```cpp
void input_data(Line &line) { ... }
void input_data(Rectangle &rect) { ... }
void input_data(Circle &circle) { ... }
void draw(Line &line) { ...... } 
void draw(Rectangle &rect) { ...... }
void draw(Circle &circle) { ...... }
double area(Rectangle &rect) { ... }
double area(Circle &circle) { ... }
```

### 输入输出实现
- 需要显式类型判断和分支处理
- 增加新图形种类时需要修改代码

## 抽象数据类型Stack实现
### 抽象基类
```cpp
class Stack {
    public:
        virtual void push(int i)=0;
        virtual void pop(int& i)=0;
};
```

### 具体实现类
#### ArrayStack
```cpp
class ArrayStack: public Stack {
    int elements[100],top;
    public:
        ArrayStack() { top = -1; }
        void push(int i) { ...... }
        void pop(int& i) { ...... }
};
```

#### LinkedStack
```cpp
class LinkedStack: public Stack {
    struct Node {
        int content;
        Node *next;
    } *first;
    public:
        LinkedStack() { first = NULL; }
        void push(int i) { ...... }
        void pop(int& i) { ...... }
};
```

### 使用示例
```cpp
void f(Stack *p) {
    p->push(...); //动态绑定
    p->pop(...);  //动态绑定
}

int main() {
    ArrayStack st1;
    LinkedStack st2;
    f(&st1);  //OK
    f(&st2);  //OK
}
```

## 抽象类实现访问控制
### 传统方式的问题
```cpp
//A.h
class A {
    int i,j;
    public:
        A();
        A(int x,int y);
        void f(int x);
};

//B.cpp
void func(A *p) {
    p->f(2); //Ok
    *((int *)p) = 1; //绕过访问控制
    *((int *)p+1) = 2; //绕过访问控制
}
```

### 抽象类解决方案
```cpp
//I_A.h
class I_A {
    public:
        virtual void f(int)=0;
};

//B.cpp
void func(I_A *p) {
    p->f(2);  //Ok
    *((int *)p) = 1; //无法确定数据成员
}

//A.cpp
class A: public I_A {
    int i,j;
    public:
        A();
        A(int x,int y);
        void f(int x);
};
```