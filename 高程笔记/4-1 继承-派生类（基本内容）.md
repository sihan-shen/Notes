
## 主要内容
- 继承的基本概念
- 单继承
- protected访问控制
- 继承方式与子类型
- 派生类对象的初始化与消亡处理
- 派生类对象的赋值

## 软件复用
- 在开发新软件时复用现有软件或部分功能
- 直接复用困难的原因：
  - 功能不完全匹配
- 解决方案：
  - 修改源代码（缺点：可靠性差、易出错）
  - 使用函数库（缺点：不完全符合需求）

## 继承概念
- 定义新类时包含已有类的功能，并添加/重定义新功能
- 基类（父类）与派生类（子类）关系
- 派生类可以：
  - 定义新成员
  - 重定义基类成员函数
- 继承类型：
  - 单继承：一个直接基类
  - 多继承：多个直接基类

## 继承的作用
1. 支持软件复用
2. 对对象进行层次分类
3. 便于问题描述和解决
4. 支持概念组合（如"在职研究生"）
5. 支持增量开发（版本升级）

## 单继承语法
```cpp
class <派生类名>:[<继承方式>] <基类名> {
    <成员说明表>
};
```
- 继承方式：public/protected/private（默认private）

## 派生类成员访问
- 派生类拥有基类所有成员（除构造/析构/赋值操作符）
- 派生类不能直接访问基类私有成员
- protected成员：
  - 可在派生类中访问
  - 对实例用户不可见

## 继承与封装的矛盾
- 派生类可能需要访问基类private成员
- protected访问控制缓解此矛盾：
  - public接口：供实例用户使用
  - protected接口：供派生类使用

## 成员作用域与隐藏
- 派生类作用域嵌套在基类作用域中
- 派生类同名成员会隐藏基类成员
- 访问被隐藏成员：`基类名::成员`
- 使用`using`声明可开放基类成员

## 继承方式
- 决定基类成员在派生类中的访问控制
- 三种继承方式：
  - public
  - protected
  - private
- 可调整继承方式：
  ```cpp
  class B: private A {
  public:
      A::f1; // 调整为public
  protected:
      A::f2; // 调整为protected
  };
  ```

## 子类型
- public继承的派生类是基类的子类型
- 派生类对象可替代基类对象：
  - 赋值给基类对象
  - 作为基类指针/引用
  - 作为函数参数传递

## 派生类对象初始化
1. 构造顺序：
   - 基类构造函数
   - 派生类构造函数
2. 默认调用基类默认构造函数
3. 显式调用基类构造函数：
   ```cpp
   B(int i, int j):A(i) { y = j; }
   ```

## 继承构造函数（C++11）
- 使用`using`声明继承基类构造函数
- 派生类成员初始化方式：
  1. 就地初始化
  2. 初始化列表

## 构造/析构顺序
- 构造顺序：基类→成员对象→派生类
- 析构顺序：派生类→成员对象→基类

## 派生类拷贝构造
- 隐式拷贝构造调用基类拷贝构造
- 自定义拷贝构造默认调用基类默认构造
- 显式调用基类拷贝构造：
  ```cpp
  B(const B& b):A(b) { ... }
  ```

## 派生类赋值操作
- 隐式赋值操作调用基类赋值操作
- 自定义赋值操作需显式调用基类赋值：
  ```cpp
  *(A*)this = b;
  // 或
  this->A::operator=(b);
  ```

## 实例：职员与经理类
```cpp
class Employee { // 职员类
    String name;
    int salary;
    // ...
};

class Manager: public Employee { // 经理类
    Employee* group[MAX_NUM_OF_EMPS];
    int num_of_emps;
    // ...
};
```