
## 消息的多态性
- 相同的一条消息可以发送到不同类的对象，从而会得到不同的解释（处理）
- 对于具有public继承关系的两个类：
  - 一条可以发送到基类对象的消息，也可以发送到派生类对象
  - 如果在基类和派生类中都给出了对这条消息的处理，则存在特殊的多态性

## 消息的绑定
### 静态绑定
- 编译时刻根据对象的类型决定采用哪个消息处理函数
- 示例：
  ```cpp
  A a;
  B b;
  a.f();    // A的f
  b.f();    // B的f
  b.A::f(); // A的f
  ```

### 动态绑定
- 基类指针或引用可以指向或引用基类对象或派生类对象
- C++默认使用静态绑定
- 实际需求：根据实际引用/指向的对象决定调用哪个函数
- 实现方式：在基类中使用虚函数

## 虚函数
### 定义与作用
- 格式：`virtual <成员函数声明>`
- 作用：
  1. 指定消息采用动态绑定
  2. 指出基类中可以被派生类重定义的成员函数

### 重定义（覆盖）
- 派生类中定义的、与基类虚函数具有相同型构的成员函数
- 相同型构要求：
  - 函数名、参数个数和类型相同
  - 返回值类型相同或是基类返回值类型的public派生类

## 虚函数说明
1. 只有类的成员函数可以是虚函数（静态成员函数不能）
2. 构造函数不能是虚函数，析构函数可以（往往）是虚函数
3. 基类中的虚函数在派生类及其派生类中同型构的成员函数都是虚函数（virtual可不写）
4. 只有通过指针或引用访问虚函数时才进行动态绑定
5. 基类的构造函数和析构函数中对虚函数的调用不进行动态绑定

## 动态绑定实现
- 通过虚函数表(vtable)实现
- 示例：
  ```cpp
  typedef void (*FuncPtr)(void *);
  typedef FuncPtr *vptr;
  p->f();  // 编译为 (*(*(vptr*)p))(p);
  p->g();  // 编译为 (*(*(vptr*)p+1))(p);
  ```

## 通过基类指针访问派生类成员
- 直接访问派生类新成员会出错
- 安全做法：使用dynamic_cast进行类型转换
  ```cpp
  B *q = dynamic_cast<B *>(p);
  if (q != NULL) q->g();
  ```

## 何时需要虚函数
1. 基类成员函数实现可能不是最优，未来可能有更好实现
2. 基类无法给出某些成员函数的实现，必须由派生类实现（纯虚函数）