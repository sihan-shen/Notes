
## 对象的初始化
- **构造函数**是类的特殊成员函数，用于初始化对象的数据成员。
- **特点**：
  - 与类同名，无返回值类型。
  - 对象创建时自动调用。
  - 可重载，但无参数（或所有参数有默认值）的构造函数称为**默认构造函数**。

### 示例代码
```cpp
class A {
    int x, y;
public:
    // 默认构造函数
    A() { x = 0; y = 0; }
    
    // 重载构造函数
    A(int x1) { x = x1; y = 0; }
    A(int x1, int y1) { x = x1; y = y1; }
    
    // 合并为带默认参数的构造函数（C++11）
    A(int x1 = 0, int y1 = 0) : x(x1), y(y1) {}
};
```

### 对象创建方式
```cpp
A a1;          // 调用默认构造函数
A a2(1);       // 调用 A(int)
A a3("abcd");  // 调用 A(char*)
A* p1 = new A; // 动态分配，调用默认构造函数
```

---

## 成员初始化表
- **作用**：在构造函数中初始化 `const` 成员、引用成员或需要高效初始化的成员。
- **特点**：
  - 初始化顺序与成员**声明顺序**一致，与初始化列表顺序无关。
  - 执行顺序：**就地初始化 → 初始化列表 → 构造函数体**（C++11）。

### 示例代码
```cpp
class A {
    int x = 0;         // 就地初始化（C++11）
    const int y = 1;
    int& z = x;        // 引用成员
public:
    A() : y(1), z(x) { // 初始化列表
        x = 2;         // 构造函数体赋值
    }
};
```

---

## 析构函数
- **作用**：对象消亡时自动调用，用于释放额外申请的资源（如动态内存）。
- **特点**：
  - 命名：`~类名()`，无参数，不可重载。
  - 显式调用析构函数不会销毁对象，但会释放资源（需谨慎使用）。

### 示例代码
```cpp
class String {
    int len;
    char* str;
public:
    String(char* s) {
        len = strlen(s);
        str = new char[len + 1]; // 动态分配内存
        strcpy(str, s);
    }
    ~String() {
        delete[] str; // 释放内存
        str = nullptr; // 避免悬空指针
    }
};

void func() {
    String s("abcd"); // 构造函数调用
} // s 离开作用域，析构函数自动调用
```

---

## 成员对象的初始化和消亡
- **初始化顺序**：
  - 先调用成员对象的构造函数，再调用本类的构造函数。
  - 多个成员对象的构造函数按**声明顺序**调用。
- **消亡顺序**：
  - 先调用本类的析构函数，再逆序调用成员对象的析构函数。

### 示例代码
```cpp
class A {
public:
    A() { /* ... */ }
    A(int) { /* ... */ }
};

class B {
    A a; // 成员对象
    int y;
public:
    B() : y(0) {}            // 调用 A 的默认构造函数
    B(int i, int j) : a(j), y(i) {} // 显式调用 A(int)
};

B b2(1, 2); // 调用 A(int) 和 B(int, int)
```

---

## 注意事项
1. **隐式生成函数**：
   - 若类未定义构造函数但包含成员对象，编译器隐式生成默认构造函数（调用成员对象的默认构造函数）。
   - 若类未定义析构函数，编译器隐式生成析构函数（调用成员对象的析构函数）。

2. **资源管理**：
   - 动态分配的资源（如堆内存）必须在析构函数中释放，避免内存泄漏。
   - 显式调用析构函数后，对象仍存在但可能处于无效状态。

3. **构造/析构顺序**：
   - 构造顺序：基类 → 成员对象 → 自身。
   - 析构顺序：自身 → 成员对象 → 基类（逆序）。

---

通过理解构造函数和析构函数的机制，可有效管理对象生命周期和资源，避免常见问题如内存泄漏或悬空指针。