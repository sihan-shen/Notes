
## 主要内容
- 泛型（类属）的基本概念
- 函数模板
- 类模板
- 模板的复用问题

## 应用场景
在程序设计中，经常需要用到一些功能完全相同的程序实体，但它们所涉及的数据类型不同。

### 示例
- 对不同元素类型的数组进行排序的函数：
  ```cpp
  void int_sort(int x[],int num);
  void double_sort(double x[],int num);
  void A_sort(A x[],int num);
  ```
- 元素类型不同的栈类：
  ```cpp
  class IntStack { int buf[100]; public: void push(int); void pop(int&); };
  class DoubleStack { double buf[100]; public: void push(double); void pop(double&); };
  class AStack { A buf[100]; public: void push(A); void pop(A&); };
  ```

## 目标
- 实现软件复用，减少代码量
- 降低开发与维护成本
- 提升软件生产力

## 泛型（类属）
- 定义：一个程序实体能对多种类型的数据进行操作或描述的特性
- 类属程序实体：
  - 类属函数：能对不同类型数据完成相同操作的函数
  - 类属类：成员类型可变但功能不变的类
- 泛型程序设计：基于类属特性的程序设计技术

## 类属函数实现方式
1. 通用指针类型参数（C语言做法）
2. 函数模板

### 通用指针实现示例
```cpp
typedef unsigned char byte;
void sort(void *base, unsigned int num, unsigned int element_size, 
          bool (*cmp)(const void *, const void *)) {
    // 实现细节...
}
```

### 函数模板
```cpp
template <class T1, class T2, ...>
<返回值类型> <函数名>(<参数表>) {
    // 函数体
}
```

#### 排序函数模板示例
```cpp
template <class T> 
void sort(T elements[], unsigned int count) {
    // 实现细节...
}
```

## 函数模板实例化
- 隐式实例化：编译器根据实参类型自动推导
- 显式实例化：`max<double>(x,m)`

### 带非类型参数的函数模板
```cpp
template <class T, int size>
void f(T a) {
    T temp[size];
    // ...
}
```

## 类模板
- 定义：类定义中用到的类型可变但操作不变的类
- 格式：
```cpp
template <class T1,class T2,...>
class <类名> {
    // 类成员说明
}
```

### 栈类模板示例
```cpp
template <class T> 
class Stack {
    T buffer[100];
    int top;
public:
    Stack() { top = -1; }
    void push(const T &x);
    void pop(T &x);
};
```

### 类模板实例化
- 显式实例化：`Stack<int> st1;`
- 静态成员：不同实例不共享静态成员

### 带非类型参数的类模板
```cpp
template <class T, int size> 
class Stack {
    T buffer[size];
    // ...
};
```

## 模板的复用
- 模板属于一种多态
- 实例化在编译时刻进行
- 必须见到源代码才能实例化

### 模板复用问题
- 多模块编译导致重复实例
- 解决方案：
  - 编译时处理
  - 链接时处理

## 类模板的友元函数
- 一对一友元：
```cpp
template <class T>
class A {
    friend void f<T>(A<T>& a);
};
```
- 多对多友元：
```cpp
template <class T>
class A {
    template <class T1> friend void f(A<T1>& a);
};
```