
### 流水线数据通路和控制
- 日常生活中的流水线处理例子：洗衣服
- 单周期处理器模型和流水线性能比较
- 适合流水线执行的指令集特征
- 流水线数据通路设计（以RV32I子集为例）
- 流水线控制逻辑设计
- 流水线冒险的概念

#### 洗衣店流水线示例
- 串行方式：4批衣服需360分钟（90N分钟）
- 流水线方式：210分钟（30+N×40+20分钟）
- 性能提升：当N很大时，流水线比串行方式提高约3倍

#### 单周期处理器关键路径
- Load操作关键路径 = PC传播时间 + 指令存储器访问时间 + 寄存器文件访问时间 + ALU加法时间 + 数据存储器访问时间 + 寄存器文件建立时间 + 时钟偏移

#### 流水线性能比较
- 单周期模型：每条指令8ns，N条指令8Nns
- 流水线模型：每阶段2ns，N条指令(4+N)×2ns
- 理想情况下比串行方式提高约4倍（各阶段均衡时为5倍）

### 流水线指令集设计
- 有利于流水线的指令集特征：
  - 指令长度一致（如RV32I固定32位）
  - 格式少且源寄存器位置固定
  - load/store指令才能访存
  - 内存对齐存放

### 指令流水线阶段
#### R-type指令
1. Ifetch：取指令并计算PC+4
2. Reg/Dec：从寄存器取数并译码
3. Exec：ALU计算
4. Wr：结果写回寄存器

#### Load指令
1. Ifetch
2. Reg/Dec
3. Exec：计算内存地址
4. Mem：读存储器
5. Wr：数据写回寄存器

#### 结构冒险问题
- 现象：多条指令同时使用同一功能部件
- 解决方案：规定每个功能部件每条指令只能用一次，且在相同阶段使用

### 流水线数据通路设计
#### 五阶段流水线
1. 取指令段(IF)：Instruction Memory、Adder
2. 译码/读寄存器(ID)：Extender、寄存器读口
3. 执行(EX)：ALU、Adder
4. 存储器(M)：Data Memory
5. 写回(WB)：寄存器写口

#### 控制信号
- ID阶段：ExtOp
- EX阶段：ALUASrc、ALUBSrc、ALUctr
- M阶段：MemWr、Branch、Jump
- WB阶段：MemtoReg、RegWr

### 流水线冒险
#### 数据冒险
- 现象：后面指令需要前面指令的结果数据
- 解决方法：
  - 转发(Forwarding)技术
  - Load-use冒险需要阻塞一个时钟
  - 编译器优化指令顺序

#### 控制冒险
- 现象：转移指令改变执行流程
- 解决方法：
  - 静态分支预测
  - 动态分支预测
  - 延迟分支技术

#### 结构冒险
- 现象：硬件资源冲突
- 解决方法：功能部件分离（如IM和DM分开）

### 高级流水线技术
#### 指令级并行(ILP)
1. 超流水线：增加流水线级数
2. 多发射流水线：同时发射多条指令

#### 静态多发射(VLIW)
- 由编译器完成指令打包和冒险处理
- 示例：RV32I 2-发射处理器

#### 动态多发射(超标量)
- 由硬件动态完成指令打包和冒险处理
- 三种执行模式：
  - 按序发射按序完成
  - 按序发射无序完成
  - 无序发射无序完成

### 三种处理器实现方式比较
- 单周期：固定长时钟周期（由最长指令决定）
- 多周期：不同指令不同时钟周期数
- 流水线：指令分阶段执行，理想情况下每个时钟完成一条指令